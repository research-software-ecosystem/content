{
    "accessibility": "Open access (with restrictions)",
    "additionDate": "2021-05-05T10:52:21Z",
    "biotoolsCURIE": "biotools:multilcs",
    "biotoolsID": "multilcs",
    "collectionID": [
        "MATLAB",
        "File Exchange"
    ],
    "cost": "Free of charge (with restrictions)",
    "credit": [
        {
            "name": "milchsage",
            "typeEntity": "Person",
            "typeRole": [
                "Primary contact"
            ],
            "url": "https://www.mathworks.com/matlabcentral/profile/4452621-milchsage"
        }
    ],
    "description": "multiLCS is a MATLAB script for finding the longest common subsequence for multiple sequences.",
    "download": [
        {
            "type": "Screenshot",
            "url": "https://www.mathworks.com//matlabcentral/images/default_screenshot.jpg"
        }
    ],
    "editPermission": {
        "type": "private"
    },
    "homepage": "https://www.mathworks.com/matlabcentral/fileexchange/55827-multilcs",
    "language": [
        "MATLAB"
    ],
    "lastUpdate": "2021-05-13T18:47:29.968126Z",
    "name": "multiLCS",
    "operatingSystem": [
        "Windows",
        "Linux",
        "Mac"
    ],
    "owner": "Kigaard",
    "publication": [
        {
            "doi": "10.1186/1471-2105-7-S4-S4",
            "metadata": {
                "abstract": "Background: Searching for the longest common sequence (LCS) of multiple biosequences is one of the most fundamental tasks in bioinformatics. In this paper, we present a parallel algorithm named FAST LCS to speedup the computation for finding LCS. Results: A fast parallel algorithm for LCS is presented. The algorithm first constructs a novel successor table to obtain all the identical pairs and their levels. It then obtains the LCS by tracing back from the identical character pairs at the last level. Effective pruning techniques are developed to significantly reduce the computational complexity. Experimental results on gene sequences in the tigr database show that our algorithm is optimal and much more efficient than other leading LCS algorithms. Conclusion: We have developed one of the fastest parallel LCS algorithms on an MPP parallel computing model. For two sequences X and Y with lengths n and m, respectively, the memory required is max{4*(n+1)+4*(m+1), L}, where L is the number of identical character pairs. The time complexity is O(L) for sequential execution, and O( LCS(X, Y) ) for parallel execution, where LCS(X, Y) is the length of the LCS of X1, and X2,...,Xn, sequences X1, X2,..., Xn, the time complexity is O(L) for sequential execution, and O( LCS(X1, X2,..., Xn) ) for parallel execution. Experimental results support our analysis by showing significant improvement of the proposed method over other leading LCS algorithms. \u00a9 2006 Chen et al; licensee BioMed Central Ltd.",
                "authors": [
                    {
                        "name": "Chen Y."
                    },
                    {
                        "name": "Wan A."
                    },
                    {
                        "name": "Liu W."
                    }
                ],
                "citationCount": 31,
                "date": "2006-12-12T00:00:00Z",
                "journal": "BMC Bioinformatics",
                "title": "A fast parallel algorithm for finding the longest common sequence of multiple biosequences"
            }
        }
    ],
    "toolType": [
        "Library"
    ],
    "topic": [
        {
            "term": "Biomedical science",
            "uri": "http://edamontology.org/topic_3344"
        },
        {
            "term": "Biology",
            "uri": "http://edamontology.org/topic_3070"
        }
    ],
    "version": [
        "1.0"
    ]
}